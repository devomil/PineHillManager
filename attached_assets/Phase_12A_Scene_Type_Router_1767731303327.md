# Phase 12A: Scene Type Router Enhancement

## Objective

Create an intelligent routing system that analyzes visual directions and determines whether content should be generated by:
1. **AI Video Providers** (Kling, Runway, Luma, etc.) - For photorealistic/live-action content
2. **Remotion Motion Graphics Engine** - For animated graphics, kinetic text, infographics

## Prerequisites

- Phases 1-11 complete
- `universal-video-service.ts` exists and handles asset generation
- `ai-video-providers.ts` has provider configurations

## What This Phase Creates

- `server/services/motion-graphics-router.ts` - Routing decision service
- `server/services/motion-graphics-generator.ts` - Orchestration service
- `shared/types/motion-graphics-types.ts` - Type definitions
- Updates to `universal-video-service.ts` - Integration

## What Success Looks Like

```
[MotionRouter] Analyzing visual direction for scene 3...
[MotionRouter] Keywords detected: "animated", "transformation", "metaphor"
[MotionRouter] Decision: MOTION_GRAPHICS (confidence: 0.92)
[MotionRouter] Component type: visual-metaphor
[MotionGenerator] Generating tree growth animation...
[MotionGenerator] Config created for Remotion render
```

---

## Step 1: Create Type Definitions

Create `shared/types/motion-graphics-types.ts`:

```typescript
// shared/types/motion-graphics-types.ts

/**
 * Types of motion graphic content the system can generate
 */
export type MotionGraphicType = 
  | 'kinetic-typography'
  | 'stat-counter'
  | 'progress-bar'
  | 'animated-chart'
  | 'process-flow'
  | 'comparison'
  | 'tree-growth'
  | 'network-visualization'
  | 'transformation'
  | 'journey-path'
  | 'split-screen'
  | 'before-after'
  | 'picture-in-picture'
  | 'bullet-list-animated'
  | 'timeline'
  | 'abstract-organic';

/**
 * Routing decision result
 */
export interface RoutingDecision {
  useMotionGraphics: boolean;
  confidence: number; // 0-1
  detectedKeywords: string[];
  suggestedType: MotionGraphicType | null;
  reasoning: string;
  fallbackToAI: boolean;
}

/**
 * Base configuration for all motion graphics
 */
export interface MotionGraphicBaseConfig {
  type: MotionGraphicType;
  duration: number; // in seconds
  fps: number;
  width: number;
  height: number;
  backgroundColor: string;
  brandColors: {
    primary: string;
    secondary: string;
    accent: string;
    text: string;
  };
}

/**
 * Kinetic typography configuration
 */
export interface KineticTypographyConfig extends MotionGraphicBaseConfig {
  type: 'kinetic-typography';
  text: string;
  animationStyle: 'word-by-word' | 'character' | 'line-by-line' | 'bounce' | 'wave' | 'reveal' | 'split' | 'typewriter';
  fontSize: number;
  fontFamily: string;
  fontWeight: string;
  textColor: string;
  position: 'center' | 'top' | 'bottom' | 'custom';
  customPosition?: { x: number; y: number };
  staggerDelay: number; // frames between each word/character
  entranceDuration: number; // frames for entrance animation
  holdDuration: number; // frames to hold at full visibility
  exitDuration: number; // frames for exit animation
  easing: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'spring' | 'bounce';
  textShadow?: boolean;
  backgroundBox?: {
    enabled: boolean;
    color: string;
    opacity: number;
    padding: number;
    borderRadius: number;
  };
}

/**
 * Stat counter configuration
 */
export interface StatCounterConfig extends MotionGraphicBaseConfig {
  type: 'stat-counter';
  stats: Array<{
    value: number;
    label: string;
    prefix?: string;
    suffix?: string;
    decimals?: number;
  }>;
  layout: 'horizontal' | 'vertical' | 'grid';
  animationDuration: number; // frames for count animation
  staggerDelay: number;
  numberStyle: {
    fontSize: number;
    fontWeight: string;
    color: string;
  };
  labelStyle: {
    fontSize: number;
    fontWeight: string;
    color: string;
  };
}

/**
 * Process flow configuration
 */
export interface ProcessFlowConfig extends MotionGraphicBaseConfig {
  type: 'process-flow';
  steps: Array<{
    title: string;
    description?: string;
    icon?: string;
  }>;
  layout: 'horizontal' | 'vertical' | 'circular';
  connectorStyle: 'line' | 'arrow' | 'dotted' | 'animated';
  stepStyle: {
    shape: 'circle' | 'square' | 'rounded' | 'hexagon';
    size: number;
    backgroundColor: string;
    borderColor: string;
    textColor: string;
  };
  animationType: 'sequential' | 'simultaneous' | 'build';
  stepDuration: number; // frames per step
}

/**
 * Tree growth / organic metaphor configuration
 */
export interface TreeGrowthConfig extends MotionGraphicBaseConfig {
  type: 'tree-growth';
  trunkColor: string;
  branchColor: string;
  leafColor: string;
  labels: Array<{
    text: string;
    position: 'root' | 'branch' | 'leaf';
    branchIndex?: number;
  }>;
  growthDuration: number; // frames for full growth
  style: 'natural' | 'geometric' | 'minimal' | 'organic';
  rootsVisible: boolean;
  rootLabels?: string[];
}

/**
 * Network visualization configuration
 */
export interface NetworkVisualizationConfig extends MotionGraphicBaseConfig {
  type: 'network-visualization';
  nodes: Array<{
    id: string;
    label: string;
    size?: number;
    color?: string;
  }>;
  connections: Array<{
    from: string;
    to: string;
    label?: string;
    animated?: boolean;
  }>;
  layout: 'force' | 'circular' | 'hierarchical' | 'grid';
  nodeStyle: {
    shape: 'circle' | 'square' | 'rounded';
    defaultSize: number;
    defaultColor: string;
  };
  connectionStyle: {
    color: string;
    width: number;
    animated: boolean;
  };
  animationType: 'nodes-first' | 'connections-first' | 'simultaneous';
}

/**
 * Split screen configuration
 */
export interface SplitScreenConfig extends MotionGraphicBaseConfig {
  type: 'split-screen';
  layout: '2-horizontal' | '2-vertical' | '3-horizontal' | '3-vertical' | '4-grid' | 'pip';
  panels: Array<{
    mediaUrl: string;
    mediaType: 'image' | 'video';
    label?: string;
    labelPosition?: 'top' | 'bottom';
  }>;
  dividerStyle: {
    width: number;
    color: string;
    animated: boolean;
  };
  transitionType: 'simultaneous' | 'sequential' | 'wipe';
  transitionDuration: number;
}

/**
 * Before/After comparison configuration
 */
export interface BeforeAfterConfig extends MotionGraphicBaseConfig {
  type: 'before-after';
  beforeMedia: {
    url: string;
    type: 'image' | 'video';
    label: string;
  };
  afterMedia: {
    url: string;
    type: 'image' | 'video';
    label: string;
  };
  transitionStyle: 'slider' | 'fade' | 'wipe' | 'flip';
  sliderPosition?: number; // 0-100, for slider style
  labelStyle: {
    fontSize: number;
    color: string;
    backgroundColor: string;
  };
}

/**
 * Animated bullet list configuration
 */
export interface BulletListAnimatedConfig extends MotionGraphicBaseConfig {
  type: 'bullet-list-animated';
  items: string[];
  bulletStyle: 'dot' | 'check' | 'arrow' | 'number' | 'custom';
  customBullet?: string;
  animationType: 'fade' | 'slide-left' | 'slide-right' | 'slide-up' | 'pop';
  staggerDelay: number;
  itemDuration: number;
  textStyle: {
    fontSize: number;
    fontWeight: string;
    color: string;
  };
  bulletColor: string;
  position: 'left' | 'center' | 'right';
  verticalPosition: number; // percentage from top
  backgroundBox?: {
    enabled: boolean;
    color: string;
    opacity: number;
  };
}

/**
 * Timeline configuration
 */
export interface TimelineConfig extends MotionGraphicBaseConfig {
  type: 'timeline';
  events: Array<{
    date: string;
    title: string;
    description?: string;
  }>;
  orientation: 'horizontal' | 'vertical';
  lineStyle: {
    color: string;
    width: number;
  };
  markerStyle: {
    shape: 'circle' | 'diamond' | 'square';
    size: number;
    color: string;
  };
  animationType: 'sequential' | 'build';
  eventDuration: number;
}

/**
 * Union type for all motion graphic configs
 */
export type MotionGraphicConfig = 
  | KineticTypographyConfig
  | StatCounterConfig
  | ProcessFlowConfig
  | TreeGrowthConfig
  | NetworkVisualizationConfig
  | SplitScreenConfig
  | BeforeAfterConfig
  | BulletListAnimatedConfig
  | TimelineConfig;

/**
 * Result from motion graphics generation
 */
export interface MotionGraphicResult {
  success: boolean;
  config: MotionGraphicConfig;
  renderInstructions: {
    compositionId: string;
    props: Record<string, any>;
    durationInFrames: number;
  };
  error?: string;
}
```

---

## Step 2: Create Motion Graphics Router Service

Create `server/services/motion-graphics-router.ts`:

```typescript
// server/services/motion-graphics-router.ts

import { RoutingDecision, MotionGraphicType } from '../../shared/types/motion-graphics-types';

/**
 * Keywords that indicate motion graphics should be used
 */
const MOTION_GRAPHIC_KEYWORDS: Record<string, { weight: number; suggestedType: MotionGraphicType }> = {
  // Strong indicators (weight 1.0)
  'animated': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'animation': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'motion graphic': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'motion graphics': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'kinetic typography': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'kinetic text': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'text animation': { weight: 1.0, suggestedType: 'kinetic-typography' },
  'animated text': { weight: 1.0, suggestedType: 'kinetic-typography' },
  
  // Split screen indicators
  'split screen': { weight: 1.0, suggestedType: 'split-screen' },
  'split-screen': { weight: 1.0, suggestedType: 'split-screen' },
  'side by side': { weight: 0.9, suggestedType: 'split-screen' },
  'side-by-side': { weight: 0.9, suggestedType: 'split-screen' },
  'montage': { weight: 0.8, suggestedType: 'split-screen' },
  'multi-panel': { weight: 0.9, suggestedType: 'split-screen' },
  'picture in picture': { weight: 0.9, suggestedType: 'picture-in-picture' },
  'picture-in-picture': { weight: 0.9, suggestedType: 'picture-in-picture' },
  'pip': { weight: 0.8, suggestedType: 'picture-in-picture' },
  
  // Comparison indicators
  'before and after': { weight: 1.0, suggestedType: 'before-after' },
  'before after': { weight: 1.0, suggestedType: 'before-after' },
  'before/after': { weight: 1.0, suggestedType: 'before-after' },
  'comparison': { weight: 0.8, suggestedType: 'comparison' },
  'compare': { weight: 0.7, suggestedType: 'comparison' },
  'versus': { weight: 0.7, suggestedType: 'comparison' },
  'vs': { weight: 0.6, suggestedType: 'comparison' },
  
  // Data visualization indicators
  'infographic': { weight: 1.0, suggestedType: 'stat-counter' },
  'data visualization': { weight: 1.0, suggestedType: 'animated-chart' },
  'chart': { weight: 0.8, suggestedType: 'animated-chart' },
  'graph': { weight: 0.8, suggestedType: 'animated-chart' },
  'statistics': { weight: 0.8, suggestedType: 'stat-counter' },
  'stats': { weight: 0.7, suggestedType: 'stat-counter' },
  'numbers': { weight: 0.6, suggestedType: 'stat-counter' },
  'percentage': { weight: 0.7, suggestedType: 'stat-counter' },
  'counter': { weight: 0.8, suggestedType: 'stat-counter' },
  'progress bar': { weight: 0.9, suggestedType: 'progress-bar' },
  'progress': { weight: 0.5, suggestedType: 'progress-bar' },
  
  // Process/flow indicators
  'process flow': { weight: 1.0, suggestedType: 'process-flow' },
  'flowchart': { weight: 0.9, suggestedType: 'process-flow' },
  'steps': { weight: 0.6, suggestedType: 'process-flow' },
  'step by step': { weight: 0.8, suggestedType: 'process-flow' },
  'step-by-step': { weight: 0.8, suggestedType: 'process-flow' },
  'timeline': { weight: 0.9, suggestedType: 'timeline' },
  'sequence': { weight: 0.5, suggestedType: 'process-flow' },
  
  // Metaphor/abstract indicators
  'visual metaphor': { weight: 1.0, suggestedType: 'tree-growth' },
  'metaphor': { weight: 0.8, suggestedType: 'tree-growth' },
  'transformation': { weight: 0.8, suggestedType: 'transformation' },
  'transform': { weight: 0.7, suggestedType: 'transformation' },
  'morph': { weight: 0.9, suggestedType: 'transformation' },
  'morphing': { weight: 0.9, suggestedType: 'transformation' },
  'tree': { weight: 0.5, suggestedType: 'tree-growth' },
  'roots': { weight: 0.6, suggestedType: 'tree-growth' },
  'growing': { weight: 0.5, suggestedType: 'tree-growth' },
  'growth': { weight: 0.5, suggestedType: 'tree-growth' },
  'network': { weight: 0.7, suggestedType: 'network-visualization' },
  'connected': { weight: 0.5, suggestedType: 'network-visualization' },
  'interconnected': { weight: 0.7, suggestedType: 'network-visualization' },
  'connections': { weight: 0.6, suggestedType: 'network-visualization' },
  'nodes': { weight: 0.7, suggestedType: 'network-visualization' },
  'web': { weight: 0.4, suggestedType: 'network-visualization' },
  'journey': { weight: 0.5, suggestedType: 'journey-path' },
  'path': { weight: 0.4, suggestedType: 'journey-path' },
  'abstract': { weight: 0.6, suggestedType: 'abstract-organic' },
  'organic': { weight: 0.4, suggestedType: 'abstract-organic' },
  
  // List indicators
  'bullet points': { weight: 0.8, suggestedType: 'bullet-list-animated' },
  'bullet list': { weight: 0.8, suggestedType: 'bullet-list-animated' },
  'list': { weight: 0.4, suggestedType: 'bullet-list-animated' },
  'actionable steps': { weight: 0.7, suggestedType: 'bullet-list-animated' },
  
  // 2D/3D indicators
  '2d animation': { weight: 1.0, suggestedType: 'kinetic-typography' },
  '2d': { weight: 0.5, suggestedType: 'kinetic-typography' },
  '3d animation': { weight: 0.8, suggestedType: 'transformation' },
  'cartoon': { weight: 0.6, suggestedType: 'kinetic-typography' },
  'illustrated': { weight: 0.5, suggestedType: 'kinetic-typography' },
  'illustration': { weight: 0.5, suggestedType: 'kinetic-typography' },
};

/**
 * Keywords that indicate AI video should be used (negative indicators)
 */
const AI_VIDEO_KEYWORDS: string[] = [
  'person',
  'woman',
  'man',
  'people',
  'face',
  'human',
  'talking',
  'speaking',
  'walking',
  'running',
  'lifestyle',
  'testimonial',
  'interview',
  'cinematic',
  'dramatic',
  'nature footage',
  'b-roll',
  'product shot',
  'real world',
  'documentary',
  'vlog',
  'live action',
  'photorealistic',
  'realistic',
];

/**
 * Threshold for routing to motion graphics
 */
const ROUTING_THRESHOLD = 0.6;

class MotionGraphicsRouter {
  
  /**
   * Analyze visual direction and determine routing
   */
  analyzeVisualDirection(
    visualDirection: string,
    narration?: string,
    sceneType?: string
  ): RoutingDecision {
    const lowerDirection = visualDirection.toLowerCase();
    const lowerNarration = (narration || '').toLowerCase();
    
    console.log(`[MotionRouter] Analyzing: "${visualDirection.substring(0, 100)}..."`);
    
    // Detect motion graphic keywords
    const detectedKeywords: string[] = [];
    let totalWeight = 0;
    let suggestedType: MotionGraphicType | null = null;
    let highestWeight = 0;
    
    for (const [keyword, config] of Object.entries(MOTION_GRAPHIC_KEYWORDS)) {
      if (lowerDirection.includes(keyword) || lowerNarration.includes(keyword)) {
        detectedKeywords.push(keyword);
        totalWeight += config.weight;
        
        if (config.weight > highestWeight) {
          highestWeight = config.weight;
          suggestedType = config.suggestedType;
        }
      }
    }
    
    // Check for AI video indicators (negative weight)
    let aiVideoScore = 0;
    for (const keyword of AI_VIDEO_KEYWORDS) {
      if (lowerDirection.includes(keyword)) {
        aiVideoScore += 0.3;
      }
    }
    
    // Calculate confidence
    const motionGraphicsScore = Math.min(totalWeight, 2.0); // Cap at 2.0
    const netScore = motionGraphicsScore - aiVideoScore;
    const confidence = Math.max(0, Math.min(1, netScore));
    
    // Special case: if "text overlay with" is mentioned, it's likely motion graphics
    if (lowerDirection.includes('text overlay with') || 
        lowerDirection.includes('text overlay showing') ||
        lowerDirection.includes('overlay with')) {
      if (!suggestedType) suggestedType = 'bullet-list-animated';
      if (confidence < 0.7) {
        return {
          useMotionGraphics: true,
          confidence: 0.85,
          detectedKeywords: [...detectedKeywords, 'text overlay'],
          suggestedType,
          reasoning: 'Text overlay content detected - routing to motion graphics for clean text rendering',
          fallbackToAI: false,
        };
      }
    }
    
    // Make routing decision
    const useMotionGraphics = confidence >= ROUTING_THRESHOLD && suggestedType !== null;
    
    // Build reasoning
    let reasoning: string;
    if (useMotionGraphics) {
      reasoning = `Motion graphics keywords detected (${detectedKeywords.join(', ')}). Confidence: ${(confidence * 100).toFixed(0)}%`;
    } else if (detectedKeywords.length > 0 && aiVideoScore > motionGraphicsScore) {
      reasoning = `Mixed signals: motion keywords (${detectedKeywords.join(', ')}) but also live-action indicators. Defaulting to AI video.`;
    } else if (detectedKeywords.length === 0) {
      reasoning = 'No motion graphics keywords detected. Using AI video generation.';
    } else {
      reasoning = `Confidence (${(confidence * 100).toFixed(0)}%) below threshold. Using AI video.`;
    }
    
    console.log(`[MotionRouter] Decision: ${useMotionGraphics ? 'MOTION_GRAPHICS' : 'AI_VIDEO'}`);
    console.log(`[MotionRouter] Keywords: ${detectedKeywords.join(', ') || 'none'}`);
    console.log(`[MotionRouter] Confidence: ${(confidence * 100).toFixed(0)}%`);
    
    return {
      useMotionGraphics,
      confidence,
      detectedKeywords,
      suggestedType,
      reasoning,
      fallbackToAI: !useMotionGraphics,
    };
  }
  
  /**
   * Get the appropriate motion graphic type based on content analysis
   */
  determineMotionGraphicType(
    visualDirection: string,
    narration: string,
    detectedKeywords: string[]
  ): MotionGraphicType {
    const lower = visualDirection.toLowerCase();
    
    // Priority order for type detection
    if (lower.includes('split screen') || lower.includes('side by side') || lower.includes('montage')) {
      return 'split-screen';
    }
    
    if (lower.includes('before') && lower.includes('after')) {
      return 'before-after';
    }
    
    if (lower.includes('tree') || lower.includes('root') || lower.includes('growth')) {
      return 'tree-growth';
    }
    
    if (lower.includes('network') || lower.includes('connected') || lower.includes('interconnected')) {
      return 'network-visualization';
    }
    
    if (lower.includes('stat') || lower.includes('counter') || lower.includes('percentage') || lower.includes('%')) {
      return 'stat-counter';
    }
    
    if (lower.includes('process') || lower.includes('step') || lower.includes('flow')) {
      return 'process-flow';
    }
    
    if (lower.includes('timeline') || lower.includes('chronolog')) {
      return 'timeline';
    }
    
    if (lower.includes('bullet') || lower.includes('list') || lower.includes('actionable')) {
      return 'bullet-list-animated';
    }
    
    if (lower.includes('transform') || lower.includes('morph')) {
      return 'transformation';
    }
    
    // Default to kinetic typography for text-heavy content
    if (lower.includes('text') || lower.includes('typography') || lower.includes('animated')) {
      return 'kinetic-typography';
    }
    
    // Fallback based on narration content
    if (narration) {
      const bulletPoints = narration.match(/[•\-\*]\s/g);
      if (bulletPoints && bulletPoints.length >= 2) {
        return 'bullet-list-animated';
      }
      
      const numbers = narration.match(/\d+%|\d+\s*(percent|million|billion|thousand)/gi);
      if (numbers && numbers.length >= 2) {
        return 'stat-counter';
      }
    }
    
    // Default fallback
    return 'kinetic-typography';
  }
  
  /**
   * Extract content from visual direction for motion graphic generation
   */
  extractContentFromDirection(
    visualDirection: string,
    narration: string,
    type: MotionGraphicType
  ): Record<string, any> {
    const content: Record<string, any> = {};
    
    switch (type) {
      case 'bullet-list-animated':
        // Try to extract list items from narration or direction
        const listMatch = narration.match(/(?:•|\-|\*|\d+\.)\s*([^•\-\*\n]+)/g);
        if (listMatch) {
          content.items = listMatch.map(item => 
            item.replace(/^(?:•|\-|\*|\d+\.)\s*/, '').trim()
          );
        } else {
          // Try to extract from visual direction
          const colonMatch = visualDirection.match(/:\s*(.+)/);
          if (colonMatch) {
            content.items = colonMatch[1].split(/,|;/).map(s => s.trim()).filter(Boolean);
          }
        }
        break;
        
      case 'stat-counter':
        // Extract numbers and labels
        const statMatches = narration.match(/(\d+(?:\.\d+)?)\s*(%|percent|million|billion|thousand)?\s*(?:of\s+)?([a-zA-Z\s]+)/gi);
        if (statMatches) {
          content.stats = statMatches.map(match => {
            const parts = match.match(/(\d+(?:\.\d+)?)\s*(%|percent|million|billion|thousand)?\s*(?:of\s+)?(.+)/i);
            if (parts) {
              return {
                value: parseFloat(parts[1]),
                suffix: parts[2] || '',
                label: parts[3]?.trim() || 'Value',
              };
            }
            return null;
          }).filter(Boolean);
        }
        break;
        
      case 'process-flow':
        // Extract steps
        const stepMatches = narration.match(/(?:step\s*\d+|first|second|third|then|next|finally)[:\s]+([^.!?]+)/gi);
        if (stepMatches) {
          content.steps = stepMatches.map(step => ({
            title: step.replace(/(?:step\s*\d+|first|second|third|then|next|finally)[:\s]+/i, '').trim(),
          }));
        }
        break;
        
      case 'tree-growth':
        // Extract labels for roots/branches
        const labelMatches = visualDirection.match(/(?:roots?|branch(?:es)?|leaf|leaves)\s*(?:transforming\s*into|representing|showing|labeled?)\s*([^,.\n]+)/gi);
        if (labelMatches) {
          content.labels = labelMatches.map(match => {
            const text = match.replace(/(?:roots?|branch(?:es)?|leaf|leaves)\s*(?:transforming\s*into|representing|showing|labeled?)\s*/i, '').trim();
            return { text, position: match.toLowerCase().includes('root') ? 'root' : 'branch' };
          });
        }
        break;
        
      default:
        // For kinetic typography, use the narration or a key phrase
        content.text = narration || visualDirection.substring(0, 100);
        break;
    }
    
    return content;
  }
}

export const motionGraphicsRouter = new MotionGraphicsRouter();
```

---

## Step 3: Create Motion Graphics Generator Service

Create `server/services/motion-graphics-generator.ts`:

```typescript
// server/services/motion-graphics-generator.ts

import { 
  MotionGraphicType, 
  MotionGraphicConfig,
  MotionGraphicResult,
  MotionGraphicBaseConfig,
  KineticTypographyConfig,
  StatCounterConfig,
  ProcessFlowConfig,
  TreeGrowthConfig,
  BulletListAnimatedConfig,
  SplitScreenConfig,
} from '../../shared/types/motion-graphics-types';
import { motionGraphicsRouter } from './motion-graphics-router';
import { brandBibleService } from './brand-bible-service';

/**
 * Default configuration values
 */
const DEFAULT_CONFIG: Partial<MotionGraphicBaseConfig> = {
  fps: 30,
  width: 1920,
  height: 1080,
  backgroundColor: '#FFFFFF',
};

/**
 * Brand-specific defaults for Pine Hill Farm
 */
const PHF_BRAND_COLORS = {
  primary: '#2D5A27',    // Forest Green
  secondary: '#D4A574',  // Warm Gold
  accent: '#8B4513',     // Saddle Brown
  text: '#FFFFFF',       // White
  background: '#F5F5DC', // Beige
};

class MotionGraphicsGenerator {
  
  /**
   * Generate motion graphics configuration for a scene
   */
  async generateMotionGraphic(
    visualDirection: string,
    narration: string,
    sceneType: string,
    duration: number
  ): Promise<MotionGraphicResult> {
    console.log(`[MotionGenerator] Generating motion graphic for scene type: ${sceneType}`);
    
    try {
      // Get routing decision
      const routing = motionGraphicsRouter.analyzeVisualDirection(
        visualDirection, 
        narration, 
        sceneType
      );
      
      if (!routing.useMotionGraphics || !routing.suggestedType) {
        return {
          success: false,
          config: null as any,
          renderInstructions: null as any,
          error: 'Content not suitable for motion graphics',
        };
      }
      
      // Determine final type
      const graphicType = motionGraphicsRouter.determineMotionGraphicType(
        visualDirection,
        narration,
        routing.detectedKeywords
      );
      
      console.log(`[MotionGenerator] Type determined: ${graphicType}`);
      
      // Extract content from direction
      const extractedContent = motionGraphicsRouter.extractContentFromDirection(
        visualDirection,
        narration,
        graphicType
      );
      
      // Get brand colors
      const brandColors = await this.getBrandColors();
      
      // Generate configuration based on type
      const config = await this.generateConfigForType(
        graphicType,
        extractedContent,
        brandColors,
        duration
      );
      
      // Generate render instructions
      const renderInstructions = this.generateRenderInstructions(config);
      
      console.log(`[MotionGenerator] Config generated successfully`);
      
      return {
        success: true,
        config,
        renderInstructions,
      };
      
    } catch (error: any) {
      console.error(`[MotionGenerator] Error:`, error.message);
      return {
        success: false,
        config: null as any,
        renderInstructions: null as any,
        error: error.message,
      };
    }
  }
  
  /**
   * Get brand colors from brand bible service
   */
  private async getBrandColors(): Promise<typeof PHF_BRAND_COLORS> {
    try {
      const bible = await brandBibleService.getBrandBible();
      return {
        primary: bible.colors?.primary || PHF_BRAND_COLORS.primary,
        secondary: bible.colors?.secondary || PHF_BRAND_COLORS.secondary,
        accent: bible.colors?.accent || PHF_BRAND_COLORS.accent,
        text: bible.colors?.text || PHF_BRAND_COLORS.text,
        background: bible.colors?.background || PHF_BRAND_COLORS.background,
      };
    } catch {
      return PHF_BRAND_COLORS;
    }
  }
  
  /**
   * Generate configuration for specific motion graphic type
   */
  private async generateConfigForType(
    type: MotionGraphicType,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS,
    duration: number
  ): Promise<MotionGraphicConfig> {
    const baseConfig: MotionGraphicBaseConfig = {
      ...DEFAULT_CONFIG,
      type,
      duration,
      fps: 30,
      width: 1920,
      height: 1080,
      backgroundColor: brandColors.background,
      brandColors,
    };
    
    switch (type) {
      case 'kinetic-typography':
        return this.generateKineticTypographyConfig(baseConfig, content, brandColors);
        
      case 'stat-counter':
        return this.generateStatCounterConfig(baseConfig, content, brandColors);
        
      case 'process-flow':
        return this.generateProcessFlowConfig(baseConfig, content, brandColors);
        
      case 'tree-growth':
        return this.generateTreeGrowthConfig(baseConfig, content, brandColors);
        
      case 'bullet-list-animated':
        return this.generateBulletListConfig(baseConfig, content, brandColors);
        
      case 'split-screen':
        return this.generateSplitScreenConfig(baseConfig, content, brandColors);
        
      default:
        // Default to kinetic typography
        return this.generateKineticTypographyConfig(baseConfig, content, brandColors);
    }
  }
  
  /**
   * Generate kinetic typography configuration
   */
  private generateKineticTypographyConfig(
    baseConfig: MotionGraphicBaseConfig,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS
  ): KineticTypographyConfig {
    const fps = baseConfig.fps;
    const totalFrames = baseConfig.duration * fps;
    
    return {
      ...baseConfig,
      type: 'kinetic-typography',
      text: content.text || 'Your wellness journey starts here',
      animationStyle: 'word-by-word',
      fontSize: 72,
      fontFamily: 'Inter, system-ui, sans-serif',
      fontWeight: '700',
      textColor: brandColors.primary,
      position: 'center',
      staggerDelay: 6, // frames between words
      entranceDuration: Math.round(fps * 0.3), // 0.3 seconds per word entrance
      holdDuration: Math.round(totalFrames * 0.6), // 60% of time holding
      exitDuration: Math.round(fps * 0.5), // 0.5 seconds exit
      easing: 'spring',
      textShadow: true,
      backgroundBox: {
        enabled: true,
        color: '#FFFFFF',
        opacity: 0.9,
        padding: 24,
        borderRadius: 12,
      },
    };
  }
  
  /**
   * Generate stat counter configuration
   */
  private generateStatCounterConfig(
    baseConfig: MotionGraphicBaseConfig,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS
  ): StatCounterConfig {
    const fps = baseConfig.fps;
    
    // Default stats if none extracted
    const stats = content.stats?.length > 0 ? content.stats : [
      { value: 93, suffix: '%', label: 'Customer Satisfaction' },
      { value: 1853, suffix: '', label: 'Year Founded' },
      { value: 300, suffix: '+', label: 'Products' },
    ];
    
    return {
      ...baseConfig,
      type: 'stat-counter',
      stats,
      layout: stats.length <= 3 ? 'horizontal' : 'grid',
      animationDuration: Math.round(fps * 2), // 2 seconds for count animation
      staggerDelay: Math.round(fps * 0.3), // 0.3 seconds between stats
      numberStyle: {
        fontSize: 96,
        fontWeight: '800',
        color: brandColors.primary,
      },
      labelStyle: {
        fontSize: 24,
        fontWeight: '500',
        color: brandColors.accent,
      },
    };
  }
  
  /**
   * Generate process flow configuration
   */
  private generateProcessFlowConfig(
    baseConfig: MotionGraphicBaseConfig,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS
  ): ProcessFlowConfig {
    const fps = baseConfig.fps;
    
    // Default steps if none extracted
    const steps = content.steps?.length > 0 ? content.steps : [
      { title: 'Step 1', description: 'Begin your journey' },
      { title: 'Step 2', description: 'Make progress' },
      { title: 'Step 3', description: 'Achieve results' },
    ];
    
    return {
      ...baseConfig,
      type: 'process-flow',
      steps,
      layout: steps.length <= 4 ? 'horizontal' : 'vertical',
      connectorStyle: 'animated',
      stepStyle: {
        shape: 'circle',
        size: 80,
        backgroundColor: brandColors.primary,
        borderColor: brandColors.secondary,
        textColor: brandColors.text,
      },
      animationType: 'sequential',
      stepDuration: Math.round(fps * 1.5), // 1.5 seconds per step
    };
  }
  
  /**
   * Generate tree growth configuration
   */
  private generateTreeGrowthConfig(
    baseConfig: MotionGraphicBaseConfig,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS
  ): TreeGrowthConfig {
    const fps = baseConfig.fps;
    
    // Default labels if none extracted
    const labels = content.labels?.length > 0 ? content.labels : [
      { text: 'Nutrition', position: 'branch' as const },
      { text: 'Exercise', position: 'branch' as const },
      { text: 'Sleep', position: 'branch' as const },
      { text: 'Mindfulness', position: 'branch' as const },
    ];
    
    return {
      ...baseConfig,
      type: 'tree-growth',
      trunkColor: brandColors.accent,
      branchColor: brandColors.primary,
      leafColor: brandColors.secondary,
      labels,
      growthDuration: Math.round(fps * (baseConfig.duration * 0.7)), // 70% of duration for growth
      style: 'organic',
      rootsVisible: true,
      rootLabels: ['Root Cause', 'Foundation', 'Core Health'],
    };
  }
  
  /**
   * Generate bullet list configuration
   */
  private generateBulletListConfig(
    baseConfig: MotionGraphicBaseConfig,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS
  ): BulletListAnimatedConfig {
    const fps = baseConfig.fps;
    
    // Default items if none extracted
    const items = content.items?.length > 0 ? content.items : [
      'First actionable step',
      'Second actionable step',
      'Third actionable step',
    ];
    
    return {
      ...baseConfig,
      type: 'bullet-list-animated',
      items,
      bulletStyle: 'check',
      animationType: 'slide-left',
      staggerDelay: Math.round(fps * 0.5), // 0.5 seconds between items
      itemDuration: Math.round(fps * 0.4), // 0.4 seconds per item animation
      textStyle: {
        fontSize: 36,
        fontWeight: '600',
        color: brandColors.text,
      },
      bulletColor: brandColors.secondary,
      position: 'left',
      verticalPosition: 30, // 30% from top
      backgroundBox: {
        enabled: true,
        color: brandColors.primary,
        opacity: 0.95,
      },
    };
  }
  
  /**
   * Generate split screen configuration
   */
  private generateSplitScreenConfig(
    baseConfig: MotionGraphicBaseConfig,
    content: Record<string, any>,
    brandColors: typeof PHF_BRAND_COLORS
  ): SplitScreenConfig {
    return {
      ...baseConfig,
      type: 'split-screen',
      layout: '2-vertical',
      panels: content.panels || [
        { mediaUrl: '', mediaType: 'image' as const, label: 'Before' },
        { mediaUrl: '', mediaType: 'image' as const, label: 'After' },
      ],
      dividerStyle: {
        width: 4,
        color: brandColors.secondary,
        animated: true,
      },
      transitionType: 'simultaneous',
      transitionDuration: Math.round(baseConfig.fps * 0.5),
    };
  }
  
  /**
   * Generate Remotion render instructions
   */
  private generateRenderInstructions(config: MotionGraphicConfig): {
    compositionId: string;
    props: Record<string, any>;
    durationInFrames: number;
  } {
    const compositionId = `MotionGraphic_${config.type}`;
    const durationInFrames = config.duration * config.fps;
    
    return {
      compositionId,
      props: { ...config },
      durationInFrames,
    };
  }
}

export const motionGraphicsGenerator = new MotionGraphicsGenerator();
```

---

## Step 4: Integrate with Universal Video Service

Update `server/services/universal-video-service.ts` to use the motion graphics router:

### Add imports at the top:
```typescript
import { motionGraphicsRouter } from './motion-graphics-router';
import { motionGraphicsGenerator } from './motion-graphics-generator';
```

### Add routing check before AI video generation:

Find the section where video/image generation happens for each scene, and add this check BEFORE calling AI providers:

```typescript
// In the scene processing loop, BEFORE calling AI video/image generation:

// Check if this scene should use motion graphics instead of AI
const routingDecision = motionGraphicsRouter.analyzeVisualDirection(
  scene.visualDirection || '',
  scene.narration || '',
  scene.type
);

if (routingDecision.useMotionGraphics) {
  console.log(`[Assets] Scene ${i + 1}: Routing to Motion Graphics (${routingDecision.suggestedType})`);
  
  const motionResult = await motionGraphicsGenerator.generateMotionGraphic(
    scene.visualDirection || '',
    scene.narration || '',
    scene.type,
    scene.duration
  );
  
  if (motionResult.success) {
    // Store motion graphics config instead of media URL
    updatedProject.scenes[i].assets = {
      ...updatedProject.scenes[i].assets,
      useMotionGraphics: true,
      motionGraphicsConfig: motionResult.config,
      motionGraphicsRenderInstructions: motionResult.renderInstructions,
      provider: 'remotion-motion-graphics',
    };
    
    console.log(`[Assets] Scene ${i + 1}: Motion graphics config generated`);
    continue; // Skip AI video generation for this scene
  } else {
    console.log(`[Assets] Scene ${i + 1}: Motion graphics failed, falling back to AI`);
    // Fall through to AI video generation
  }
}

// Existing AI video generation code continues here...
```

---

## Step 5: Test the Router

Add a test endpoint to verify routing decisions:

```typescript
// Add to server/routes.ts

import { motionGraphicsRouter } from './services/motion-graphics-router';
import { motionGraphicsGenerator } from './services/motion-graphics-generator';

// Test motion graphics routing
router.post('/api/test-motion-routing', async (req, res) => {
  try {
    const { visualDirection, narration, sceneType } = req.body;
    
    const routing = motionGraphicsRouter.analyzeVisualDirection(
      visualDirection || '',
      narration || '',
      sceneType || 'general'
    );
    
    let config = null;
    if (routing.useMotionGraphics) {
      const result = await motionGraphicsGenerator.generateMotionGraphic(
        visualDirection || '',
        narration || '',
        sceneType || 'general',
        10 // 10 second default duration
      );
      config = result.success ? result.config : null;
    }
    
    res.json({
      routing,
      config,
    });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});
```

Test with:
```bash
curl -X POST http://localhost:5000/api/test-motion-routing \
  -H "Content-Type: application/json" \
  -d '{
    "visualDirection": "Animated visual metaphor: tree with visible root system, roots transforming into interconnected health factors",
    "narration": "Our functional health approach addresses the root cause of your concerns.",
    "sceneType": "explanation"
  }'
```

Expected output:
```json
{
  "routing": {
    "useMotionGraphics": true,
    "confidence": 0.92,
    "detectedKeywords": ["animated", "visual metaphor", "tree", "roots", "transforming", "interconnected"],
    "suggestedType": "tree-growth",
    "reasoning": "Motion graphics keywords detected...",
    "fallbackToAI": false
  },
  "config": {
    "type": "tree-growth",
    "duration": 10,
    ...
  }
}
```

---

## Verification Checklist

Before moving to Phase 12B, confirm:

- [ ] `shared/types/motion-graphics-types.ts` exists with all type definitions
- [ ] `motion-graphics-router.ts` exists and exports `motionGraphicsRouter`
- [ ] `motion-graphics-generator.ts` exists and exports `motionGraphicsGenerator`
- [ ] Keywords are detected correctly from visual directions
- [ ] Confidence scores are reasonable (>0.6 for motion graphics content)
- [ ] Type determination works (tree-growth for tree content, etc.)
- [ ] Brand colors are loaded from brand bible service
- [ ] Test endpoint returns expected routing decisions
- [ ] Integration with universal-video-service is prepared
- [ ] Console logs show routing decisions

---

## Troubleshooting

### "Keywords not detected"
- Check if keywords are lowercase in the detection
- Verify visual direction is being passed correctly
- Check for typos in keyword list

### "Wrong type suggested"
- Review keyword weights in MOTION_GRAPHIC_KEYWORDS
- Check priority order in determineMotionGraphicType
- Add more specific keywords if needed

### "Brand colors not loading"
- Verify brand-bible-service is working
- Check fallback to PHF_BRAND_COLORS

### "Integration not working"
- Ensure imports are correct
- Check that routing check happens BEFORE AI generation
- Verify scene data structure matches expectations

---

## Next Phase

Once routing is working correctly, proceed to **Phase 12B: Kinetic Typography System** to build the actual Remotion components for text animation.
